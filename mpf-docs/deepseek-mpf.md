The Comprehensive Mission Pinball Framework (MPF) Reference GuideSection 1: Foundational Concepts and Architecture1.1. What is the Mission Pinball Framework?The Mission Pinball Framework (MPF) is a free, open-source, Python-based software framework designed to power real, physical pinball machines.1 Originally started by Brian Madden in 2014, it has since grown into a robust, community-developed project maintained by volunteers.2 MPF is not a pinball simulator; rather, it is the "brain" or operating system that runs on a computer—such as a Windows PC, Mac, Linux machine, or Raspberry Pi—housed inside a pinball machine cabinet.4From this central computer, MPF controls every electronic and mechanical component of the machine. This includes:Solenoids and Coils: Firing the coils for flippers, pop bumpers, slingshots, and ball eject mechanisms.1Lights and LEDs: Controlling general illumination (GI), matrix-based incandescent lamps, and modern RGB or RGBW LEDs for complex light shows.7Switches: Reading inputs from rollovers, targets, optos, and other playfield switches to track the ball's position and player actions.7Displays: Driving various display types, from classic Dot Matrix Displays (DMDs) and segment displays to modern high-definition LCD screens.1Motors and Servos: Managing motors for interactive toys and servos for diverters or other animated mechanics.5The framework has been successfully implemented in hundreds of custom "homebrew" pinball machines and has also been used to power several commercially released titles.1 Its versatility allows it to run on a wide range of pinball machines, including modern solid-state machines, electromechanical (EM) machines, and completely custom builds.11.2. Core Philosophy: Configuration Over CodeThe foundational principle of MPF is its "configuration over code" approach.4 This means that the vast majority of a pinball game's logic, rules, hardware definitions, and behaviors are defined in simple, text-based configuration files rather than through traditional, line-by-line programming.1 These configuration files use the YAML (YAML Ain't Markup Language) format, which is designed to be human-readable and easy to edit.9This design choice is not merely for convenience; it is a strategic decision that makes pinball development accessible to a much broader audience. Hobbyists with expertise in electronics, woodworking, or art can create a full-featured pinball machine without needing to be expert software developers. It is estimated that approximately 90% of what is needed to create a complete pinball game can be accomplished purely through these YAML files.4This accessibility is a direct catalyst for the framework's community-driven growth. As a project developed and maintained entirely by volunteers in their spare time, its survival and evolution depend on active community participation.2 A high barrier to entry, such as requiring advanced Python programming for basic tasks, would limit the pool of potential users and contributors. By lowering this barrier with a human-readable configuration system, MPF empowers more people to successfully complete their projects. These successful users are then more likely to participate in community forums, contribute to the documentation, and even submit code fixes, creating a positive feedback loop that strengthens the entire ecosystem.2 While custom Python code can be integrated for advanced or unique features, the core of the game is built upon a foundation that prioritizes clarity and ease of use.1.3. The Dual-Process Architecture: Game Engine & Media ControllerA critical architectural feature of MPF is its separation into two distinct, concurrently running processes: the MPF Game Engine and the MPF Media Controller.11 These two processes communicate with each other using a specialized protocol called BCP (Backbox Control Protocol), which allows them to run independently while staying synchronized.11MPF Game Engine (mpf): This is the core of the framework. It is a real-time, deterministic process responsible for all critical game logic and hardware control. Its duties include reading switch states, firing coils with precise timing, managing game rules, tracking scores, and maintaining player state. This engine is designed for speed and reliability, ensuring that time-sensitive actions like flipper responses happen instantly.11MPF Media Controller (MC): This is a separate process dedicated to handling all non-deterministic, resource-intensive audio-visual tasks. This includes rendering graphics on an LCD, playing sound effects and music, displaying videos, and managing complex animations and widgets.1 The legacy Media Controller (mpf-mc) was built using the Kivy framework, while the modern and recommended version is the Godot Media Controller (GMC), which leverages the powerful Godot game engine for advanced graphics and sound capabilities.1This dual-process design is a sophisticated solution to the inherent challenges of modern pinball development. Pinball control is a hard real-time problem where a few milliseconds of latency can make a machine feel sluggish and unplayable. In contrast, rendering high-resolution graphics and decoding audio files are computationally expensive tasks where a minor delay or a dropped frame is often acceptable.By separating these responsibilities, MPF ensures that the Media Controller's heavy workload cannot interfere with the time-critical operations of the Game Engine. This decoupling allows each process to run on a separate CPU core, making efficient use of modern multi-core processors found in computers like the Raspberry Pi.12 Furthermore, this architecture provides immense flexibility. A developer is not locked into using the default Media Controller; they can create their own using other powerful engines like Unity or write a custom solution from scratch, interfacing with the stable and reliable MPF Game Engine via BCP. This modularity makes the framework highly extensible and prepared for future advancements in display and sound technology.121.4. The Heart of MPF: The Event-Driven SystemThe Mission Pinball Framework is, at its core, an event-driven system.7 This is the single most important concept to grasp when learning to build a game with MPF. Nearly everything that occurs within the machine either posts an event or responds to an event that has been posted.16 This system is the "glue" that connects physical hardware actions to software logic and media responses.18The system operates through a central component called the Event Manager and follows a simple two-part flow 17:Posting Events: When something happens in the game, a component posts a named text-string event. For example, when a switch connected to a stand-up target is hit, the switch controller posts an event like target1_hit.17 Hundreds of different events are posted for every conceivable action: a ball draining, a mode starting, a timer completing, a player variable changing, and so on.16Handling Events: Other components within MPF can register "handlers" with the Event Manager, essentially telling it, "let me know when you see an event called target1_hit." When that event is posted, the Event Manager notifies all registered handlers, which then execute their pre-defined actions.17This event-driven model enables the creation of complex, interactive game logic from many simple, decoupled rules. Instead of writing a single, monolithic program with deeply nested if/else statements, a developer defines many small components that react to events. For example, when the left_ramp_hit event is posted:A variable_player entry in the base game mode might listen for this event to award 1,000 points.19Simultaneously, a show_player might listen for the same event to trigger a light show named ramp_show.20If a higher-priority "multiball" mode is active, its own variable_player could also listen for left_ramp_hit, award a 1,000,000 point jackpot, and be configured to block the base mode's 1,000-point score from being awarded.7The game's complex behavior emerges from the interaction of these simple, independent listeners all reacting to the same stimulus. This makes the game logic far easier to develop, debug, and modify, as each rule is self-contained and its dependencies are clearly defined by the events it listens for.Section 2: Installation and Project Setup2.1. Choosing an Installation MethodFor the current version of MPF (0.80 and newer), there are three primary installation methods, each tailored to different user needs.22Simplest Installation: Precompiled Binary: This is the fastest way to get MPF running, especially for new users. It involves downloading a single executable file for your operating system (Windows, macOS, or Linux) that contains a bundled version of Python, MPF, and all its required dependencies. No separate installation of Python is needed. The primary advantages are simplicity and guaranteed compatibility. The disadvantages include slower application startup times compared to a standard installation and the inability to customize the MPF source code or use bleeding-edge features.22Standard Installation: Pip Install (Recommended): This is the recommended approach for most users who are developing a pinball machine. It requires a local installation of Python (versions 3.8 through 3.12 are supported). The installation is done via Python's package manager, pip, within a virtual environment. This method offers fast startup times, allows for easy upgrades to the latest pre-release versions of MPF, and has the smallest disk footprint. The main prerequisite is the user's comfort with the command line and setting up a Python virtual environment.22Expert Installation: Local Repository (Developer Mode): This method is intended for advanced users who wish to contribute to MPF's development or make custom modifications to the core framework code. It involves cloning the MPF Git repository from GitHub and installing it in "developer" or "editable" mode using the command pip install -e.. This creates a direct link to the source code folder, meaning any changes made to the code are immediately active the next time MPF is run, without needing to reinstall the package.232.2. Setting Up the Python Virtual Environment (Critical Step)For the "Standard Installation" method, using a Python virtual environment is a non-negotiable prerequisite. The official documentation strongly recommends this step to prevent common and frustrating installation problems.22A virtual environment is an isolated sandbox for a Python project. It has its own Python interpreter and its own set of installed libraries, completely separate from the system's global Python installation. This is critical because MPF relies on a specific set of third-party libraries, such as pyserial and pyyaml.23 Installing these directly into the system's global environment can create version conflicts with other Python applications, a situation often referred to as "dependency hell." A virtual environment guarantees that MPF has the exact dependencies it needs to run stably, without affecting or being affected by any other software on the computer.22The process for creating and activating a virtual environment is straightforward:Open a command prompt or terminal.Navigate to a directory where you want to store your environments. It is important not to create the virtual environment folder inside your game project folder, or vice-versa.24 A common practice is to have a dedicated venvs folder in your home directory.Create the virtual environment. The command is python3 -m venv mpf-env. You can replace mpf-env with any name you choose.23Activate the environment. This command must be run every time you open a new terminal to work on your MPF project.On macOS and Linux: source mpf-env/bin/activate.25On Windows (PowerShell): mpf-env\Scripts\Activate.ps1.25 You may need to adjust your PowerShell execution policy by running Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser to allow the activation script to run.24Once the virtual environment is active, your command prompt will typically be prefixed with the environment's name (e.g., (mpf-env)), indicating that any pip commands will now operate within this isolated sandbox. You can then proceed to install MPF using pip install mpf --pre.222.3. Creating Your First Machine FolderAll the files for a specific pinball machine—configurations, modes, sounds, images, and custom code—are contained within a single directory known as the "machine folder".26 This structure makes a project portable and easy to share.The highly recommended best practice for starting a new project is to use a version control system (VCS) like Git from the very beginning. Using an online repository service like GitHub not only provides a secure backup of your work but also makes it significantly easier to collaborate and ask for help from the MPF community, as you can share a link to your code.24The standard workflow to create a new machine folder is as follows:Create a New Repository: On a service like GitHub, create a new, empty repository for your pinball project.26Clone the Repository: On your local computer, use a Git client (like GitHub Desktop, SourceTree, or the command-line tool) to "clone" the empty repository. This will create a new folder on your computer with the name of your repository. This folder is now your machine folder.26Create the config Subfolder: Inside your newly created machine folder, create a new directory named config. This folder will hold all your machine's configuration files.26Create the Main config.yaml File: Inside the config subfolder, create a new text file and name it config.yaml. Be sure your operating system is configured to show file extensions to avoid accidentally naming it config.yaml.txt.26Add the Configuration Version: Open the config.yaml file in a text editor (VS Code is highly recommended). The very first line of this file must be the configuration version directive. For the current version of MPF, this is #config_version=6. This line tells MPF which version of the configuration file specification you are using, ensuring backward compatibility as the framework evolves. There should be no spaces around the equals sign.26Commit Your Changes: Make your first commit to your Git repository with a message like "Initial project structure." Push the commit to your remote repository on GitHub. This saves your initial setup.262.4. Running MPF and the Media ControllerMPF is executed from the command line. To run your game, you must first open a terminal, activate your virtual environment, and then navigate into your machine folder.13The primary command you will use is mpf both, which starts both the MPF Game Engine and the Media Controller simultaneously. This is the standard way to run your game during development and testing.13To run the game and media controller:Bashmpf both
Other commands are available for more specific needs:mpf game: Starts only the game engine.mpf mc: Starts only the legacy (Kivy-based) media controller. For the Godot Media Controller (GMC), the project is typically run from within the Godot editor itself.25Several command-line options can be appended to modify how MPF runs, which is particularly useful for debugging:-b: Starts the game engine without attempting to connect to a media controller. Useful for testing pure hardware logic.13-c <config_file>: Tells MPF to use a specific configuration file instead of the default config.yaml.27-x or -X: Forces MPF to use a "virtual" or "smart virtual" hardware platform, respectively. This allows you to run your game code and test logic without being connected to any physical pinball hardware.28-v and -V: Enables verbose logging for the game engine (-v) and the media controller (-V). Using both (-vV) provides maximum diagnostic output, which is invaluable for troubleshooting.28Section 3: Mastering the YAML Configuration System3.1. Understanding the Machine Folder StructureA well-organized machine folder is key to managing a pinball project. MPF expects a specific directory structure to automatically find assets like modes, shows, sounds, and images. This standardized structure ensures that projects are portable and can be easily understood by other members of the community.21A typical machine folder for a moderately complex game would look like this:my_pinball_project/
├── config/
│   └── config.yaml
├── modes/
│   ├── base/
│   │   ├── config/
│   │   │   └── base.yaml
│   │   └── shows/
│   │       └── attract_show.yaml
│   └── multiball/
│       ├── config/
│       │   └── multiball.yaml
│       └── sounds/
│           └── jackpot.wav
├── shows/
│   └── skillshot_success.yaml
├── images/
│   └── logo.png
├── sounds/
│   └── background_music.ogg
└── videos/
    └── intro_video.mp4
config/: Contains the machine-wide configuration files, with config.yaml being the main entry point.26modes/: Contains a subfolder for each game mode. Each mode is a self-contained unit with its own config, shows, sounds, etc..21shows/: Holds machine-wide show files (.yaml) that can be accessed from any mode.30images/, sounds/, videos/: Store the respective media assets for the game.213.2. Machine-Wide vs. Mode-Specific Configuration FilesThe separation between machine-wide and mode-specific configuration files creates a powerful hierarchical system for game design. This structure allows for building a game in modular layers, where base behaviors can be overridden by more specific, context-sensitive rules.21Machine-Wide Configuration (config/config.yaml): This file is the foundation of your machine. It contains all the settings that are global and persistent. This is where you define the physical reality of your machine: the hardware platform, every switch, every coil, every light, and their physical addresses. It also contains global settings for the framework itself (in the mpf: section) and the list of all modes that MPF should load (modes:).9Mode-Specific Configuration (modes/<mode_name>/config/<mode_name>.yaml): Each mode has its own configuration file that is only loaded and active when that mode is running. These files define the rules and behaviors specific to that mode, such as scoring events, light shows, display content, and game logic. For example, the configuration for a multiball mode would define the jackpot scoring, the light shows for jackpots, and the rules for adding another ball.21This layering is managed by MPF's mode priority system. When multiple modes are active simultaneously (e.g., a base mode running underneath a multiball mode), the mode with the higher priority number takes precedence for any conflicting settings.32 For instance, a ramp shot might be defined in the base mode to score 1,000 points. The multiball mode, running at a higher priority, can redefine that same ramp shot to score 1,000,000 points. When the multiball mode is active, its definition overrides the base definition. When the multiball mode ends, its configuration layer is removed, and the ramp shot seamlessly reverts to its 1,000-point behavior. This allows for clean, modular game design where each mode is a self-contained package of rules that can be layered onto the game to temporarily alter its behavior in predictable ways.3.3. Leveraging Config Players for Event-Based Actions"Config players" are the primary mechanism in YAML for implementing MPF's event-driven philosophy. They are special top-level sections in a configuration file that create event handlers, linking a posted event to a specific action.20 This is how you make things happen in your game.The basic syntax is config_player_name:, followed by an event name, which is then followed by the action to perform.Here are some of the most commonly used config players:variable_player:: Modifies a player or machine variable. This is the core of the scoring system.19YAMLvariable_player:
  # When the event 'target_standup_hit' is posted,
  # add 5000 to the current player's 'score' variable.
  target_standup_hit:
    score: 5000
slide_player:: Displays a slide on the screen.20YAMLslide_player:
  # When the event 'start_multiball' is posted,
  # show the slide named 'multiball_intro_slide'.
  start_multiball:
    multiball_intro_slide:
      target: window # Specify which display to show it on
sound_player:: Plays a sound asset.20YAMLsound_player:
  # When the event 'drain_ball_shield_hit' is posted,
  # play the sound named 'shield_hit_sound'.
  drain_ball_shield_hit:
    shield_hit_sound:
      action: play
show_player:: Plays a pre-defined show (a synchronized sequence of lights, sounds, etc.).20YAMLshow_player:
  # When the event 'jackpot_awarded' is posted,
  # play the show named 'jackpot_light_show'.
  jackpot_awarded:
    jackpot_light_show:
      action: play
These players can also be triggered by conditional events, which only fire if a certain condition is true at the moment the event is posted. The condition is appended to the event name in curly braces.34YAMLvariable_player:
  # When 'left_ramp_hit' is posted, IF the player's 'shots_made' variable is 5...
  left_ramp_hit{current_player.shots_made == 5}:
    #...then post the 'start_wizard_mode' event.
    event: start_wizard_mode
Mastering config players is fundamental to building game logic in MPF.Section 4: Hardware Configuration and Pinball Mechs4.1. Defining Your Hardware Platform (hardware:)MPF's hardware-agnostic design is one of its most powerful features. It can communicate with a wide variety of pinball control systems from different manufacturers, and you can even mix and match hardware within a single machine.35 To enable this, you must first tell MPF what hardware it needs to talk to.This is done in the hardware: section of your machine-wide config.yaml file. The primary setting is platform:, which specifies the main control system you are using.36YAML# Example for a FAST Pinball controller
hardware:
  platform: fast
YAML# Example for a P-ROC/P3-ROC controller
hardware:
  platform: p_roc
After setting the platform, you must add a corresponding platform-specific configuration section to define connection details like serial ports and baud rates. For example, a FAST Pinball setup requires a fast: section where you list the COM ports for your controller boards.37 A Stern SPIKE setup requires a spike: section with similar port and node information.39YAML# Example platform-specific settings for FAST Pinball
fast:
  ports:
    - COM3
    - COM4
4.2. Configuring Switches (switches:)Every switch in your machine—from the flipper buttons to the tiniest rollover—must be defined in the switches: section of your config.yaml file.40 Each switch is given a unique, descriptive name, which is how you will refer to it throughout the rest of your configuration files.The most critical setting for each switch is number:, which defines its physical address on the hardware controller. The syntax for this number is platform-specific.For FAST Pinball: The number is a combination of the I/O board name (defined in the fast: section) and the switch input number on that board, separated by a dash. For example: cab-8 refers to switch input 8 on the I/O board named cab.41For P-ROC/OPP and others: The number is typically the direct input number on the controller board, sometimes with a board/bank prefix.40Other important switch settings include:type: NC: Specifies that a switch is "Normally Closed." This is essential for opto switches, which are active when the light beam is unbroken and become inactive when a ball breaks the beam.40debounce:: Configures how MPF filters out rapid, unintended signal changes. Set to quick for fast-response switches like flipper buttons and slingshots, and normal (the default) for most other playfield switches.41tags:: A list of text tags you can assign to a switch. This is useful for grouping switches logically. For example, tagging your flipper buttons with left_flipper and right_flipper enables the built-in "flipper cancel" feature.42YAMLswitches:
  s_left_flipper:
    number: cab-8      # FAST Pinball number syntax
    debounce: quick
    tags: left_flipper
  s_right_flipper:
    number: cab-16     # FAST Pinball number syntax
    debounce: quick
    tags: right_flipper
  s_trough_opto_1:
    number: 3208-0     # FAST Pinball number syntax
    type: NC           # This is an opto switch
4.3. Configuring Coils, Drivers, and Flippers (coils:, flippers:)Similar to switches, every coil (solenoid) in your machine is defined in the coils: section of config.yaml. This includes flippers, pop bumpers, ejectors, magnets, and more.42Key settings for a coil include:number:: The platform-specific address of the driver output that fires the coil.42default_pulse_ms:: The default duration, in milliseconds, that the coil will be energized when pulsed. This controls the strength of the coil's action.44allow_enable: true: A critical safety setting. By default, MPF will not allow a coil to be held on continuously. You must explicitly add allow_enable: true for any coil that needs to be held, such as a flipper or a magnet.42default_hold_power:: For single-wound coils that are enabled (held on), this setting (a value from 0.0 to 1.0) controls the power level using Pulse-Width Modulation (PWM) after the initial full-power pulse. This prevents the coil from overheating.42YAMLcoils:
  c_trough_eject:
    number: 3208-0
    default_pulse_ms: 20
  c_left_flipper_main:
    number: cab-0
    allow_enable: true
    default_pulse_ms: 32
    default_hold_power: 0.25
A flipper is a special type of mechanism that links a switch (the flipper button) to a coil. These are defined in the flippers: section, which creates a high-speed link between the two components.42YAMLflippers:
  left_flipper:
    main_coil: c_left_flipper_main
    activation_switch: s_left_flipper
This configuration does more than just tell the MPF software to fire the coil when the switch is active. For modern controllers that support it, this creates a hardware rule directly on the controller board.45 This means the controller itself will watch the switch input and fire the coil output directly, with microsecond-level latency that is impossible to achieve if the signal had to travel to the host computer and back. This offloading of critical, time-sensitive rules to the hardware is essential for the responsive feel of a modern pinball machine. It is also why the switch and coil for an autofire device, like a slingshot, often need to be connected to the same physical I/O board.464.4. Configuring Lights, LEDs, and GI (lights:)In modern MPF, all types of illumination—from single-color General Illumination (GI) bulbs to complex, individually-addressable RGB LEDs—are configured in a unified lights: section.8The primary challenge in configuring lights is understanding the distinction between light numbers and channel numbers.A simple, single-color light can be defined with a single number:, which corresponds to its hardware address.8An RGB LED, however, is actually three lights in one (a red, a green, and a blue element). Each of these elements has its own hardware address, or "channel."MPF provides several ways to configure these channels:Explicit Channels (channels:): You can define the hardware number for each color channel individually. This is the most flexible but also the most verbose method.8YAMLlights:
  my_rgb_led:
    type: rgb
    channels:
      red:
        number: 9-29
      green:
        number: 9-30
      blue:
        number: 9-31
Sequential Channels (start_channel:): For serial LED strips where the channels are sequential, you can define the start_channel: (the address of the first channel, typically red) and the type: (the color order, e.g., rgb for WS2812 or grb for WS2811). MPF will then calculate the subsequent channel numbers automatically.8YAMLlights:
  my_rgb_led:
    start_channel: 9-29
    type: rgb
Chaining (previous:): To simplify the configuration of long LED strips, you can define the first LED with a start_channel: and then define each subsequent LED by linking it to the previous: one. MPF will automatically calculate the correct starting channel for each LED in the chain.8YAMLlights:
  led_1:
    start_channel: 0-0
    type: rgb
  led_2:
    previous: led_1
    type: rgb
  led_3:
    previous: led_2
    type: rgb
Section 5: Building Your Game: Core Logic5.1. Modes: The Building Blocks of Game RulesModes are the fundamental organizational structure for all game logic in MPF.21 A "mode" is not just for specific in-game objectives; the entire flow of a pinball machine is managed by modes, including the attract mode, the main game, high score entry, and bonus calculations.Each mode is a self-contained package of rules, assets, and logic that resides in its own subfolder within the modes/ directory of your machine folder.21 This modular approach is central to building a complex game. Modes run in a prioritized stack. When a game starts, a base mode with a low priority is typically started. As the player achieves objectives, other modes (like a multiball mode or a wizard mode) can be started on top of it. These new modes run at a higher priority, and their rules can temporarily override the rules of the modes running beneath them in the stack.21 When the higher-priority mode ends, its rules are removed, and the game seamlessly reverts to the behavior defined by the modes still active in the stack. This system allows for a clean, layered approach to game design.5.2. Player Variables: Tracking Score, State, and ProgressPlayer variables are the memory of your game. They are key-value pairs that are stored on a per-player basis, allowing the game to track each player's individual progress.48MPF includes several default player variables, the most important of which are score and ball.48 However, the real power comes from defining your own custom variables to track anything relevant to your game's rules. This is done in the player_vars: section of a config file, where you can define a variable's name, its data type (int, str, float), and its initial value.48YAML# In a machine-wide or mode config file
player_vars:
  ramps_made:
    initial_value: 0
    value_type: int
  wizard_modes_completed:
    initial_value: 0
    value_type: int
To change the value of these variables during gameplay, you use the variable_player: config player. This component listens for events and can add to, subtract from, or set the value of any player variable.19YAMLvariable_player:
  # When the left ramp is hit, add 1 to the 'ramps_made' variable
  left_ramp_hit:
    ramps_made: 1
  # When wizard mode ends, add 1 to the 'wizard_modes_completed' variable
  wizard_mode_ended:
    wizard_modes_completed: 1
These variables can then be used in conditional events to trigger other logic (e.g., left_ramp_hit{current_player.ramps_made == 10} could start a multiball) or displayed on the screen to show the player their progress.5.3. Shots and Shot Groups: Defining Playfield TargetsIn MPF, a "shot" is any playfield element that a player is intended to shoot. This can be a single switch (like a stand-up target), or a sequence of switches that must be activated in a specific order within a certain time (like a ramp or orbit).49Shots are defined in the shots: section of a mode's config file. Each shot has a "profile" which defines its various states. A simple shot might have two states: unlit and lit. A more complex shot might have states like unlit, flashing, and complete.49 When a shot is hit, MPF posts an event that includes the shot's name and its current state (e.g., shot_ramp_lit_hit). This allows you to create logic that awards different scores or triggers different actions based on the state of the shot when it was hit.49"Shot groups" are used to manage a collection of related shots, such as a bank of targets or a set of top lanes. They are defined in the shot_groups: section and are essential for implementing features like lane change, where hitting a flipper button rotates the "lit" state among the shots in the group.51YAML# In a mode's config file
shot_groups:
  top_lanes:
    shots: s_lane_left, s_lane_middle, s_lane_right
    rotate_left_events: s_left_flipper_active
    rotate_right_events: s_right_flipper_active
5.4. Timers and Logic Blocks for Advanced RulesFor game logic that goes beyond simple "if-this-then-that" rules, MPF provides two powerful tools: timers and logic blocks.Timers (timers:): These are configurable counters that can count up or down over time. They are defined in the timers: section of a mode's config. Timers post events at each "tick" and also when they complete, making them perfect for implementing timed modes, hurry-up features, or grace periods for ball saves.52Logic Blocks: These are reusable components that track the state of multiple events to determine when a complex condition has been met.53 There are four types:Counters: Count how many times a specific event has occurred and post a "complete" event when a target count is reached. Ideal for features like "Hit the pop bumpers 50 times to light Super Jets."Accruals: Track a list of different events and post a "complete" event once all of them have occurred, regardless of the order. Perfect for "Complete all four Martian targets to start Martian Attack."Sequences: Similar to accruals, but require the events to occur in a specific, pre-defined order.State Machines: A generic state machine that allows for defining arbitrary states and transitions between them.These tools, combined with conditional events, allow for the creation of deeply layered and complex rule sets entirely within the YAML configuration files.18Section 6: The Media Controller: Crafting the Audio-Visual Experience6.1. Display Architecture: Windows, Displays, Slides, and WidgetsThe MPF Media Controller (MPF-MC or GMC) uses a layered architecture to manage everything that appears on the screen.54 Understanding this hierarchy is key to creating dynamic display content.Window: At the top level is the Window. This is the single, actual window that the operating system creates on your monitor. You can configure its size, whether it's fullscreen, and apply global post-processing effects to it (like a filter to simulate the look of a classic DMD).54Display: Within the Window, you have one or more Displays. A display is an internal, in-memory drawing canvas. While you typically have one main display that matches the size of your window, you can create multiple displays and arrange them to create complex layouts, such as a main playfield view with a smaller "picture-in-picture" display in the corner.1Slide: Each Display can show one Slide at a time. A slide is like a single screen or scene in your game—the attract mode title screen, the main scoring display, the multiball jackpot animation, etc. You will create hundreds of slides for a complete game, and the slide_player: config player is used to switch between them in response to game events.54Widget: Widgets are the actual content elements that you place onto a slide. MPF provides many types of widgets, including text, image, video, and various shapes like rectangles and ellipses. Widgets can be positioned precisely, layered on top of each other, and animated (e.g., sliding onto the screen or fading in).7This architecture can be conceptualized like a presentation software: the Window is the projector screen, the Display is the projection area, a Slide is the current slide being shown, and Widgets are the text boxes and images on that slide.546.2. Displaying Images and VideosTo display static images or play video files, you use the image and video widget types on a slide.55Image Widget: This widget displays a static image asset. You can control its size, position, and opacity.YAML# In a slide definition
widgets:
  - type: image
    image: game_logo
    width: 400
    height: 200
Video Widget: This widget is used to play video files. It has several important settings:video:: The name of the video asset to play.volume:: The volume of the video's audio track (0.0 to 1.0).auto_play:: A boolean (true/false) that determines if the video starts playing as soon as the slide is shown. Default is true.end_behavior:: What to do when the video finishes. Options are loop (start over), pause (hold on the last frame), or stop (reset to the beginning).55control_events:: A powerful feature that allows you to control video playback with game events. You can define events to play, pause, stop, or seek the video to a specific point.556.3. The Sound and Audio System: Tracks, Ducking, and Sound PlayersMPF's sound system is designed to handle the complex audio requirements of a modern pinball machine. It is configured in the sound_system: section of your config file, where you define a set of audio "tracks".56Think of tracks as channels on a mixing board. A typical setup includes three tracks:music: For background music. Usually configured to play only one sound at a time.voice: For voice callouts. Also typically configured for one sound at a time.sfx: For sound effects. This track is usually configured to allow multiple sounds to be played simultaneously (e.g., a slingshot, a pop bumper, and a target hit all at once).57Each track can have its own independent volume level. Sound assets are defined in the sounds: section and assigned to a specific track. To play a sound, you use the sound_player: config player to link a game event to a sound asset.57MPF also supports advanced audio features like ducking. This allows you to configure a track (like voice) to automatically lower the volume of another track (like music) whenever it plays a sound. This ensures that important voice callouts are clearly audible over the background music.7Section 7: Implementing Advanced Gameplay Features7.1. Shows: Synchronizing Lights, Sound, and MediaA "show" in MPF is a powerful tool for creating synchronized sequences of actions involving lights, sounds, slides, coils, and other devices.30 Shows are essentially timelines defined in their own YAML files, typically stored in a shows folder.A show consists of a series of steps. Each step has a timing value and a list of actions to perform. The timing can be:Absolute (time:): Specifies the exact time, in seconds or milliseconds from the start of the show, when the step should occur (e.g., time: 1.5s).59Relative (time:): Specifies the time to wait after the previous step has started (e.g., time: +500ms).59Duration (duration:): Specifies how long the step should last. This is useful for actions that have a duration, like a light fading from one color to another.59Within each step, you can include actions from any of the config players. For example, a single step in a jackpot show could simultaneously change the color of multiple lights, play a jackpot sound effect, and display a "JACKPOT!" slide on the screen.30Shows are started and stopped using the show_player: config player, which links a game event to the playback of a show.587.2. Multiball: Virtual Locks, Physical Locks, and Add-a-BallMPF has extensive built-in support for creating and managing multiball modes. Multiballs are defined in the multiballs: section of a mode's config, where you specify the target ball_count for the multiball to maintain.60 Multiballs work in conjunction with multiball_locks:, which track the player's progress toward starting the multiball.61There are two primary types of ball locks 62:Virtual Lock: This is the standard method in most modern pinball machines. When a player shoots a ball into a locking device, MPF "virtually" locks it by incrementing a player variable. The physical ball is then immediately ejected back onto the playfield, and a new ball is served from the trough to maintain a single ball in play. The game gives the illusion of locked balls without physically holding them.61Physical Lock: This is the traditional method where a ball shot into a locking device is physically held there. The ball device will hold the ball and request a new one from the trough. When multiball starts, all physically held balls are released.62MPF's multiball device also supports "add-a-ball" functionality. By configuring add_a_ball_events:, you can specify an event that, when posted during an active multiball, will cause the game to add one more ball into play.607.3. Skill Shots and Combo SwitchesSkill Shots: A skill shot is a special reward given to the player for making a specific, skillful shot with the ball immediately after it is plunged. In MPF, skill shots are typically implemented as a dedicated, high-priority mode that starts at the beginning of a ball (ball_started) and stops as soon as any major playfield switch is hit (playfield_active) or after a short timeout.64 This mode can use a shot_group to manage a set of lanes, random_event_player to light a random lane at the start of the ball, and variable_player to award points if the lit shot is made.64Combo Switches: MPF can recognize when a player activates two switches simultaneously or in a specific sequence. This is configured in the combo_switches: section.66 This feature is used for a variety of purposes:Flipper Cancel: The most common use. MPF has a built-in combo for when both flipper buttons are pressed at the same time, which posts the flipper_cancel event. This can be used to allow the player to skip introductory animations or bonus countdowns.68Super Skill Shot: A skill shot that requires the player to hold down a flipper button while pressing the launch button. This combo would post a unique event that could enable a different, more valuable skill shot award.66Section 8: Extending MPF: Custom Python Code8.1. When to Use Custom CodeWhile MPF's "configuration over code" philosophy allows for the creation of complex games entirely within YAML files, there are scenarios where custom Python code is necessary or more efficient.69 You should consider using custom code when:The game logic is too complex to be expressed cleanly with logic blocks and conditional events.You need to interface with a custom hardware device that doesn't have a built-in MPF platform interface.You want to implement a complex scoring algorithm that involves mathematical calculations beyond what is practical in the variable_player.You prefer to write game logic in a traditional programming language.8.2. Implementing Machine-Wide Custom LogicFor custom logic that needs to be active at all times, regardless of which game mode is running, you can create machine-wide custom code. This is ideal for managing unique hardware or global game features.70The process is as follows:Create a custom_code folder in the root of your machine folder.Inside this folder, create a Python file (e.g., my_custom_logic.py).In this file, create a class that inherits from mpf.core.custom_code.CustomCode.In your config.yaml, add a custom_code: section and list your custom code class using the format custom_code.filename.ClassName.70MPF will instantiate this class when it starts up, and its methods will remain active for the duration of the game.8.3. Adding Custom Code to Game ModesThe most common and modular way to add custom code is to attach it to a specific game mode. This code will only be active when its parent mode is running.67The process is very similar to machine-wide code:Inside a mode's folder (e.g., modes/multiball/), create a code subfolder.Inside the code folder, create a Python file (e.g., multiball.py).In this file, create a class that inherits from the base Mode class: from mpf.core.mode import Mode.67In the mode's configuration file (modes/multiball/config/multiball.yaml), add a code: setting to the mode: section, pointing to your class: code: multiball.MyMultiballClass.67Within your custom mode class, you have access to several convenience methods that are automatically called by MPF, such as mode_start(**kwargs) and mode_stop(**kwargs). You can also register event handlers, access player variables via self.player, and control any machine device through self.machine.devices, giving you full programmatic control over the game while the mode is active.67Section 9: Appendix: Quick Reference TablesTable 1: Common MPF EventsThis table lists some of the most frequently used events in MPF for triggering game logic.Event NameTriggered ByCommon Use CaseKey **kwargsball_startedA new ball for the current player is starting.Start a skill shot mode, reset mode progress.ball, playerball_endedThe current player's ball has drained.Start the bonus mode, stop ball-specific modes.ball, playermode_<name>_startedThe mode named <name> has started.Initialize timers, play an intro show or sound.(none)mode_<name>_stoppedThe mode named <name> has stopped.Clean up display elements, stop background music.(none)shot_<name>_hitThe shot named <name> was hit.Score points, play a sound, flash a light.(none)timer_<name>_completeThe timer named <name> has finished counting.End a timed mode, award a hurry-up bonus.ticks, nameflipper_cancelBoth flipper buttons are pressed simultaneously.Skip an intro show or bonus countdown.(none)player_addedA new player has joined the game.Update the display with the new player count.numTable 2: MPF Command-Line OptionsThis table provides a quick reference for the most essential command-line flags used for running and debugging MPF.Command / FlagDescriptionmpf bothStarts both the MPF game engine and the media controller. The most common command for running your game.mpf gameStarts only the MPF game engine.-bBypasses the connection to the media controller. Useful for testing hardware-only logic without a display.-c <config>Specifies a machine configuration file to use instead of the default config/config.yaml.-xRuns MPF using the "virtual" hardware platform, which simulates basic hardware but does not have smart ball tracking.-XRuns MPF using the "smart virtual" hardware platform. This is the recommended flag for testing game logic without physical hardware, as it intelligently simulates ball movement between devices.-vEnables verbose logging for the game engine, showing detailed event and device information in the console.-VEnables verbose logging for the media controller.-vVA common combination to enable maximum verbose logging for both processes, essential for deep debugging.